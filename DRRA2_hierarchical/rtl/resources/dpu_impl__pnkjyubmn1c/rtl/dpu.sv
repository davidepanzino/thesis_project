// This file was automatically generated by Vesyla. DO NOT EDIT.

// vesyla_template_start defines
`define dpu_impl _pnkjyubmn1c
`define dpu_impl_pkg _pnkjyubmn1c_pkg
// vesyla_template_end defines

// vesyla_template_start module_head
module _pnkjyubmn1c
import _pnkjyubmn1c_pkg::*;
// vesyla_template_end module_head
(
    input  logic clk_0,
    input  logic rst_n_0,
    input  logic instr_en_0,
    input  logic [RESOURCE_INSTR_WIDTH-1:0] instr_0,
    input  logic [3:0] activate_0,
    input  logic [WORD_BITWIDTH-1:0] word_data_in_0,
    output logic [WORD_BITWIDTH-1:0] word_data_out_0,
    input  logic [BULK_BITWIDTH-1:0] bulk_data_in_0,
    output logic [BULK_BITWIDTH-1:0] bulk_data_out_0,
    input  logic clk_1,
    input  logic rst_n_1,
    input  logic instr_en_1,
    input  logic [RESOURCE_INSTR_WIDTH-1:0] instr_1,
    input  logic [3:0] activate_1,
    input  logic [WORD_BITWIDTH-1:0] word_data_in_1,
    output logic [WORD_BITWIDTH-1:0] word_data_out_1,
    input  logic [BULK_BITWIDTH-1:0] bulk_data_in_1,
    output logic [BULK_BITWIDTH-1:0] bulk_data_out_1
);

    logic clk, rst_n, instruction_valid, activate;
    logic [INSTRUCTION_PAYLOAD_WIDTH-1:0] instruction;
    assign clk = clk_0;
    assign rst_n = rst_n_0;
    assign instruction_valid = instr_en_0;
    assign activate = activate_0[0];
    assign instruction = instr_0;

    // useless output
    assign word_data_out_1 = 0;
    assign bulk_data_out_0 = 0;
    assign bulk_data_out_1 = 0;

    // register inputs
    logic [WORD_BITWIDTH-1:0] in0, in1, out0;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            in0 <= 0;
            in1 <= 0;
        end else begin
            in0 <= word_data_in_0;
            in1 <= word_data_in_1;
        end
    end

  logic [$clog2(FSM_MAX_STATES)-1:0][DPU_MODE_WIDTH-1:0] mode_memory;
  logic [$clog2(FSM_MAX_STATES)-1:0][DPU_IMMEDIATE_WIDTH-1:0] immediate_memory;
  logic [$clog2(FSM_MAX_STATES)-1:0] fsm_option;
  logic [$clog2(FSM_MAX_STATES)-1:0] fsm_max_init_state;
  logic [FSM_MAX_STATES-2:0][FSM_DELAY_WIDTH-1:0] fsm_delays;
  logic [DPU_IMMEDIATE_WIDTH-1:0] immediate;
  logic [DPU_MODE_WIDTH-1:0] mode;
  logic [OPCODE_WIDTH-1:0] opcode;
  logic dpu_valid;
  logic fsm_valid;
  logic reset_accumulator;

  dpu_t dpu;
  fsm_t fsm;

  fsm #(
      .FSM_MAX_STATES(FSM_MAX_STATES),
      .FSM_DELAY_WIDTH(FSM_DELAY_WIDTH)
  ) fsm_inst (
      .clk(clk),
      .rst_n(rst_n),
      .activate(|activate),
      .fsm_delays(fsm_delays),
      .max_init_state(fsm_max_init_state),
      .state(fsm_option)
  );

  assign opcode = instruction[OPCODE_H:OPCODE_L];
  assign dpu_valid = instruction_valid && (opcode == OPCODE_DPU);
  assign fsm_valid = instruction_valid && (opcode == OPCODE_FSM);
  assign dpu = dpu_valid ? unpack_dpu(
          instruction[INSTRUCTION_PAYLOAD_WIDTH-1:0]
      ) :
      '{default: 0};
  assign fsm = fsm_valid ? unpack_fsm(
          instruction[INSTRUCTION_PAYLOAD_WIDTH-1:0]
      ) :
      '{default: 0};

  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      immediate_memory <= '0;
      mode_memory <= '0;
      fsm_max_init_state <= '0;
    end else begin
      if (dpu_valid) begin
        mode_memory[dpu._option] <= dpu._mode;
        immediate_memory[dpu._option] <= dpu._immediate;
        fsm_max_init_state <= dpu._option;
      end
    end
  end

  // TODO: we need to make the number of delays parametric somehow
  assign fsm_delays[0] = fsm._delay_0;
  assign fsm_delays[1] = fsm._delay_1;
  assign fsm_delays[2] = fsm._delay_2;

  assign mode = mode_memory[fsm_option];
  assign immediate = immediate_memory[fsm_option];

  logic signed [BITWIDTH-1:0] acc0, acc0_next;
  logic signed [BITWIDTH-1:0] adder_in0;
  logic signed [BITWIDTH-1:0] adder_in1;
  logic signed [BITWIDTH-1:0] adder_out;
  logic signed [BITWIDTH-1:0] mult_in0;
  logic signed [BITWIDTH-1:0] mult_in1;
  logic signed [BITWIDTH-1:0] mult_out;

  // signed saturateion
  localparam logic signed [BITWIDTH-1:0] MAX_RESULT = 2 ** (BITWIDTH - 1) - 1;
  localparam logic signed [BITWIDTH-1:0] MIN_RESULT = -2 ** (BITWIDTH - 1);


  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      acc0 <= '0;
    end else begin
      if (reset_accumulator) begin
        acc0 <= '0;
      end else begin
        acc0 <= acc0_next;
      end
    end
  end

  always_comb begin
    out0 = 0;
    adder_in0 = 0;
    adder_in1 = 0;
    mult_in0 = 0;
    mult_in1 = 0;
    acc0_next = 0;

    case (mode)
      DPU_MODE_ADD: begin
        adder_in0 = in0;
        adder_in1 = in1;
        out0 = adder_out;
      end
      DPU_MODE_MAC: begin
        mult_in0 = in0;
        mult_in1 = in1;
        adder_in0 = mult_out;
        adder_in1 = acc0;
        acc0_next = adder_out;
        out0 = adder_out;
      end
      DPU_MODE_MUL: begin
        mult_in0 = in0;
        mult_in1 = in1;
        out0 = mult_out;
      end
    endcase
  end

  // in future we will use ChipWare blocks for pipelined and such 
  _pnkjyubmn1c_adder adder_inst (
      .in1(adder_in0),
      .in2(adder_in1),
      .saturate(1'b1),
      .out(adder_out)
  );

  _pnkjyubmn1c_multiplier mult_inst (
      .in1(mult_in0),
      .in2(mult_in1),
      .saturate(1'b1),
      .out(mult_out)
  );

  assign word_data_out_0 = out0;

endmodule

// vesyla_template_start module_tail
// vesyla_template_end module_tail